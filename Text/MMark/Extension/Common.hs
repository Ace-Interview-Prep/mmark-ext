-- |
-- Module      :  Text.MMark.Extension.Common
-- Copyright   :  © 2017 Mark Karpov
-- License     :  BSD 3 clause
--
-- Maintainer  :  Mark Karpov <markkarpov92@gmail.com>
-- Stability   :  experimental
-- Portability :  portable
--
-- Commonly useful extensions for MMark markdown processor.

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric      #-}
{-# LANGUAGE LambdaCase         #-}
{-# LANGUAGE OverloadedStrings  #-}
{-# LANGUAGE RecordWildCards    #-}

module Text.MMark.Extension.Common
  ( -- * Table of contents
    Toc
  , tocScanner
  , toc
    -- * Punctuation prettifier
  , Punct (..)
  , punct )
where

import Data.Data (Data)
import Data.Default.Class
import Data.List.NonEmpty (NonEmpty (..))
import Data.Maybe (maybeToList)
import Data.Text (Text)
import Data.Typeable (Typeable)
import GHC.Generics
import Text.MMark
import Text.MMark.Extension (Bni, Block (..), Inline (..))
import qualified Control.Foldl        as L
import qualified Data.List.NonEmpty   as NE
import qualified Data.Text            as T
import qualified Text.MMark.Extension as Ext

----------------------------------------------------------------------------
-- Table of contents

-- | An opaque type representing table of contents produced by the
-- 'tocScanner' scanner.

newtype Toc = Toc [(Int, NonEmpty Inline)]

-- | The scanner builds table of contents 'Toc' that can then be passed to
-- 'toc' to obtain an extension that renders the table of contents in HTML.
--
-- __Note__: Top level header (level 1) is never added to the table of contents.

tocScanner
  :: Int -- ^ Up to which level (inclusive) to collect headers? Values from
         -- 2 to 6 make sense here.
  -> L.Fold Bni Toc
tocScanner cutoff = fmap (Toc . reverse) . Ext.scanner [] $ \xs block ->
  case block of
    Heading2 x -> f 2 x xs
    Heading3 x -> f 3 x xs
    Heading4 x -> f 4 x xs
    Heading5 x -> f 5 x xs
    Heading6 x -> f 6 x xs
    _          -> xs
  where
    f n a as =
      if n > cutoff
        then as
        else (n, a) : as

-- | Create an extension that replaces a certain code block with previously
-- constructed code block.

toc
  :: Text -- ^ Label of the code block to replace by table of contents
  -> Toc  -- ^ Previously generated by 'tocScanner'
  -> Extension
toc label (Toc xs) = Ext.blockTrans $ \case
  old@(CodeBlock mlabel _) ->
    case NE.nonEmpty xs of
      Nothing -> old
      Just ns ->
        if mlabel == pure label
          then renderToc ns
          else old
  other -> other

-- | Construct 'Bni' for a table of contents from given collection of
-- headers. This is a non-public helper.

renderToc :: NonEmpty (Int, NonEmpty Inline) -> Bni
renderToc = UnorderedList . NE.unfoldr f
  where
    f ((n,x) :| xs) =
      let (sitems, fitems) = span ((> n) . fst) xs
          url = Ext.headerFragment (Ext.headerId x)
      in ( Naked (Link x url Nothing :| [])
           : maybeToList (renderToc <$> NE.nonEmpty sitems)
         , NE.nonEmpty fitems )

----------------------------------------------------------------------------
-- Punctuation prettifier

-- | Settings for the punctuation-prettifying extension.

data Punct = Punct
  { punctEnDash :: !Bool
    -- ^ Whether to replace double hyphen @--@ by an en dash @–@ (default:
    -- 'True')
  , punctEmDash :: !Bool
    -- ^ Whether to replace triple hyphen @---@ by an em dash @—@ (default:
    -- 'True')
  } deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

instance Default Punct where
  def = Punct
    { punctEnDash = True
    , punctEmDash = True }

-- | Prettify punctuation according to the settings in 'Punct'.

punct :: Punct -> Extension
punct Punct {..} = Ext.inlineTrans $ \case
  Plain txt -> Plain
    . f punctEnDash (T.replace "--"  "–")
    . f punctEmDash (T.replace "---" "—")
    $ txt
  other -> other
  where
    f b g = if b then g else id
